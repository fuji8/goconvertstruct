package internal

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
)

// Generator holds the state of the analysis.
type Generator struct {
	top ast.Node

	buf bytes.Buffer // Accumulated output.

	src *ast.TypeSpec
	dst *ast.TypeSpec
}

// Generate create a file of func to covert
func (g *Generator) Generate(srcStructName, dstStructName string) error {
	if g.top == nil {
		return fmt.Errorf("parse() first")
	}

	ast.Inspect(g.top, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			switch ts.Name.Name {
			case srcStructName:
				g.src = ts
			case dstStructName:
				g.dst = ts
			}
		}
		return true
	})

	// TODO src, dst nil check
	if g.src == nil || g.dst == nil {
		return fmt.Errorf("src or dst is nil")
	}

	g.makeFunc()

	fmt.Print(string(g.format()))

	return nil
}

// Init initialize Generator
func (g *Generator) Init(fileName string) (err error) {
	fset := token.NewFileSet()
	g.top, err = parser.ParseFile(fset, fileName, nil, parser.Mode(0))
	if err != nil {
		return err
	}

	f, ok := g.top.(*ast.File)
	if !ok {
		return fmt.Errorf("top isnot ast.File")
	}
	g.printf("// Code generated by ...\n")
	g.printf("package %s\n", f.Name.Name)

	return nil
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) makeFunc() {
	g.printf("func Convert%sTo%s(src %s) (dst %s) {\n",
		g.src.Name.Name, g.dst.Name.Name, g.src.Name.Name, g.dst.Name.Name)

	dstStruct, _ := g.dst.Type.(*ast.StructType)
	for _, field := range dstStruct.Fields.List {
		// name + type
		ast.Inspect(g.src, func(n ast.Node) bool {
			if src, ok := n.(*ast.Field); ok {
				// TODO Name"s", type check
				if field.Names[0].Name == src.Names[0].Name &&
					field.Type.(*ast.Ident).Name == src.Type.(*ast.Ident).Name {
					g.printf("dst.%s = src.%s\n", field.Names[0].Name, src.Names[0].Name)
				}
				return false
			}
			return true
		})
	}

	g.printf("return\n}\n")

}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		fmt.Println(err)
		return g.buf.Bytes()
	}
	return src
}

func print(filename string) error {
	fset := token.NewFileSet()

	var node ast.Node
	node, err := parser.ParseFile(fset, filename, nil, parser.Mode(0))

	if err != nil {
		return err
	}

	ast.Inspect(node, func(n ast.Node) bool {
		ast.Print(fset, n)
		fmt.Println() // \n したい...
		return false
	})

	return nil
}
