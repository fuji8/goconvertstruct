package goconvertstruct

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"os"
	"reflect"

	"github.com/gostaticanalysis/codegen"
)

const doc = "goconvertstruct is ..."

var (
	flagOutput string

	FlagSrc, FlagDst string
)

func init() {
	Generator.Flags.StringVar(&flagOutput, "o", "", "output file name")
	Generator.Flags.StringVar(&FlagSrc, "s", "", "source struct")
	Generator.Flags.StringVar(&FlagDst, "d", "", "destination struct")
}

var Generator = &codegen.Generator{
	Name: "goconvertstruct",
	Doc:  doc,
	Run:  run,
}

var buf bytes.Buffer

func run(pass *codegen.Pass) error {

	// ASTを探索
	var srcAST, dstAST *ast.TypeSpec
	for _, f := range pass.Files {
		ast.Inspect(f, func(n ast.Node) bool {
			if ts, ok := n.(*ast.TypeSpec); ok {
				switch ts.Name.Name {
				case FlagSrc:
					if _, ok := ts.Type.(*ast.StructType); ok {
						srcAST = ts
					}
				case FlagDst:
					if _, ok := ts.Type.(*ast.StructType); ok {
						dstAST = ts
					}
				}
			}
			return true
		})
		if srcAST != nil && dstAST != nil {
			break
		}
	}

	srcType := pass.TypesInfo.TypeOf(srcAST.Type)
	dstType := pass.TypesInfo.TypeOf(dstAST.Type)
	// 生成
	fmt.Fprintf(&buf, "// Code generated by ...\n")
	fmt.Fprintf(&buf, "package %s\n", pass.Pkg.Name())
	fmt.Fprintf(&buf, "func Convert%sTo%s(src %s) (dst %s) {",
		FlagSrc, FlagDst, FlagSrc, FlagDst)

	makeFunc(dstType, srcType, "dst", "src")
	fmt.Fprintf(&buf, "return\n}\n")

	// s, _ := srcS.Type.(*ast.StructType)
	// fi := s.Fields.List[0]
	// fmt.Println(pass.TypesInfo.TypeOf(fi.Type).Underlying().String())
	// fmt.Println(pass.TypesInfo.ObjectOf(fi.Type.(*ast.Ident)).Type().Underlying())
	// fmt.Printf("%T\n", pass.TypesInfo.TypeOf(fi.Type).Underlying())
	// fmt.Println(dstS)
	// fmt.Fprintln(&buf, pass.TypesInfo.TypeOf(fi.Type))

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	if flagOutput == "" {
		pass.Print(string(src))
		return nil
	}

	f, err := os.Create(flagOutput)
	if err != nil {
		return err
	}

	fmt.Fprint(f, string(src))

	if err := f.Close(); err != nil {
		return err
	}

	return nil
}

func selectorGen(selector string, field *types.Var) string {
	//if field.Embedded() {
	//return selector
	//}
	return fmt.Sprintf("%s.%s", selector, field.Name())
}

func typeStep(t types.Type, selector string) (types.Type, string) {
	switch ty := t.(type) {
	case *types.Named:
		return ty.Underlying(), selector
	}
	return nil, ""
}

func makeFunc(dst, src types.Type, dstSelector, srcSelector string) bool {
	if types.Identical(dst, src) {
		// same
		fmt.Fprintf(&buf, "%s = %s\n", dstSelector, srcSelector)
		return true
	}

	dstRT := reflect.TypeOf(dst)
	srcRT := reflect.TypeOf(src)
	if dstRT.String() == srcRT.String() {
		// same type
		switch dst.(type) {
		case *types.Struct:
			dstT := dst.(*types.Struct)
			srcT := src.(*types.Struct)

			for i := 0; i < dstT.NumFields(); i++ {
				if dstT.Field(i).Embedded() {
					makeFunc(dstT.Field(i).Type(), srcT,
						selectorGen(dstSelector, dstT.Field(i)),
						srcSelector,
					)
					continue
				}
				for j := 0; j < srcT.NumFields(); j++ {
					if dstT.Field(i).Name() == srcT.Field(j).Name() {
						makeFunc(dstT.Field(i).Type(), srcT.Field(j).Type(),
							selectorGen(dstSelector, dstT.Field(i)),
							selectorGen(srcSelector, srcT.Field(j)),
						)
					}
				}
			}
		// case *types.Array:
		case *types.Slice:
			dstT := dst.(*types.Slice)
			srcT := src.(*types.Slice)

			// TODO fix unique i, v
			fmt.Fprintf(&buf, "%s = make(%s, len(%s))", dstSelector, dst.String(), srcSelector)
			fmt.Fprintf(&buf, "for i, v := range %s {\n", srcSelector)
			makeFunc(dstT.Elem(), srcT.Elem(),
				dstSelector+"[i]",
				srcSelector+"[i]")
			fmt.Fprintf(&buf, "}\n")
		}
	} else if dstRT.String() == "*types.Struct" || srcRT.String() == "*types.Struct" {
		if dstT, ok := dst.(*types.Struct); ok {
			for i := 0; i < dstT.NumFields(); i++ {
				if dstT.Field(i).Embedded() {
					makeFunc(dstT.Field(i).Type(), src,
						fmt.Sprintf("%s.%s", dstSelector, dstT.Field(i).Name()),
						srcSelector,
					)
					continue
				}
			}
		} else if srcT, ok := src.(*types.Struct); ok {
			for j := 0; j < srcT.NumFields(); j++ {
				written := makeFunc(dst, srcT.Field(j).Type(),
					dstSelector,
					fmt.Sprintf("%s.%s", srcSelector, srcT.Field(j).Name()),
				)
				if written {
					return true
				}
			}
		}
	} else if dstRT.String() == "*types.Slice" || srcRT.String() == "*types.Slice" {
		if dstT, ok := dst.(*types.Slice); ok {
			fmt.Fprintf(&buf, "%s = make(%s, 1)", dstSelector, dst.String())
			return makeFunc(dstT.Elem(), src, dstSelector+"[0]", srcSelector)
		} else if srcT, ok := src.(*types.Slice); ok {
			return makeFunc(dst, srcT.Elem(), dstSelector, srcSelector+"[0]")
		}
	} else {
		dstT, dstSelector := typeStep(dst, dstSelector)
		srcT, srcSelector := typeStep(src, srcSelector)
		if dstT == nil || srcT == nil {
			return false
		}
		return makeFunc(dstT, srcT, dstSelector, srcSelector)
	}
	return false
}
